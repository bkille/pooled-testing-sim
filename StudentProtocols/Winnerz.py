# DO NOT EDIT THIS FILE
# Copy this file and implement your own Protocol.isolate_positives method
#
# Create a new branch w/ your team name as the branch name
# git checkout -b your_team_name
#
# Add the file to the git repo
# git add your_file
#
# Commit it
# git commit your_file -m "A nice message"
#
# Push to your branch
# git push origin your_team_name
#
# Create a Pull Request whenever you're ready to test your method against others

from .utils import TestSample

class Protocol:
    def __init__(self, population_size: int, prevalence: float):
        self.n = population_size
        self.p = prevalence
    
    def isolate_positives(self, sample: TestSample) -> set:
        # Implement your strategy here.
        # 
        # 
        # Your goal is to return the indices of the positive samples
        # while minimizing the number of calls to sample.query
        #
        # Not correctly identifying the set of positive samples results in disqualification!
        #
        # The input will be a TestSample object, which allows you to query
        # a subset of 0 ... n-1
        #
        # sample.query([1, 3, 4]) will return True if any of 1, 3, or 4 are positive

        ### OUTLINE

        ## if less than .01 pool, neither go on, do a recursive solution 

        if self.p < .05:
            # need to test the entire pooled sample first, then try recursive solution if one is positive?
            return {}
        elif self.p > .95:
            return {i for i in range(self.n) if sample.query(set([i]))} ## my comments are top tier :) 
        ## break down into 1/4, then 1/4 and so on until we get a result
        else:
            return self.rec_isolate(sample, self.n)

        ## check top layer, if positive, break it down

        ## break down recursively again, append to a list , use a while positive ? or call a recursive function?

        # return {i for i in range(self.n) if sample.query(set([i]))}


    def rec_isolate(self, sample: TestSample, n) -> set:
        if n <= 4:
            return {i for i in range(n) if sample.query(set([i]))}
        ## Initialize divisor
        r = n / 4

        ## Divide sample into 4 and pool those
        res = set()
        for start in range(4):
            temp = sample.query(set([i for i in range(start * r, (start + 1) * r)]))
            if temp:
                res.add(self.rec_isolate(sample, n/4))
                # We need to pass a sample that is a subset of the current sample
        return res
