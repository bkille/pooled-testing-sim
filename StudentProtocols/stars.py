# DO NOT EDIT THIS FILE
# Copy this file and implement your own Protocol.isolate_positives method
#
# Create a new branch w/ your team name as the branch name
# git checkout -b your_team_name
#
# Add the file to the git repo
# git add your_file
#
# Commit it
# git commit your_file -m "A nice message"
#
# Push to your branch
# git push origin your_team_name
#
# Create a Pull Request whenever you're ready to test your method against others

from .utils import TestSample

class Protocol:
    def __init__(self, population_size: int, prevalence: float):
        self.n = population_size
        self.p = prevalence
    
    def helper(self, sample: TestSample, idx: int, size: int, skip: int) -> set:
        # should return subset of sample
        if size == 1:
            if sample.query(set([idx])):
                return set([idx])
            else:
                return set([])
        if size == 2:
            if skip:
                if sample.query(set([idx])):
                    retset = set([idx])
                    if sample.query(set([idx+ 1])):
                        retset.add(idx + 1)
                    return retset
                else:
                    return set([idx + 1])
            else:
                retset2 = set([])
                if sample.query(set(range(idx, idx + 1))):
                    retset2.add(idx)
                if sample.query(set(range(idx + 1, idx + 2))):
                    retset2.add(idx+1)
                return retset2
        if size > 2:
            pos_mark = sample.query(set(range(idx, idx + size)))
            if not pos_mark:
                return set([])
            half = (int) (size / 2 + size % 2)
            sec_idx = idx + half
            sec_size = (int) (size / 2)
            if half == 2:
                retset3 = self.helper(sample, idx, half, 0)
                if len(retset3) == 0:
                    if size == 3:
                        retset3.add(idx + 2)
                    if size == 4:
                        retset3 = retset3.union(self.helper(sample, idx + 2, half, 1))
                    return retset3
                else:
                    retset3 = retset3.union(self.helper(sample, idx + 2, size - half, 0))
                    return retset3
            if (size == 5):
                retset4 = self.helper(sample, idx, half, 0)
                if len(retset4) == 0:
                    retset4 = retset4.union(self.helper(sample, idx + 3, 2, 1))
                else:
                    retset4 = retset4.union(self.helper(sample, idx + 3, 2, 0))
                return retset4
            # general case
            retset5 = self.helper(sample, idx, half, 0)
            retset5 = retset5.union(self.helper(sample, idx + half, size - half, 0))
            return retset5


    def isolate_positives(self, sample: TestSample) -> set:
        # Implement your strategy here.
        # 
        # 
        # Your goal is to return the indices of the positive samples
        # while minimizing the number of calls to sample.query
        #
        # Not correctly identifying the set of positive samples results in disqualification!
        #
        # The input will be a TestSample object, which allows you to query
        # a subset of 0 ... n-1
        #
        # sample.query([1, 3, 4]) will return True if any of 1, 3, or 4 are positive
        retset = self.helper(sample, 0, self.n, 0)
    
        return retset
    
    

