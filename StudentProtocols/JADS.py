# DO NOT EDIT THIS FILE
# Copy this file and implement your own Protocol.isolate_positives method
#
# Create a new branch w/ your team name as the branch name
# git checkout -b your_team_name
#
# Add the file to the git repo
# git add your_file
#
# Commit it
# git commit your_file -m "A nice message"
#
# Push to your branch
# git push origin your_team_name
#
# Create a Pull Request whenever you're ready to test your method against others

from .utils import TestSample
import math

class Protocol:
    def __init__(self, population_size: int, prevalence: float):
        self.n = population_size
        self.p = prevalence
    
    

    def isolate_positives(self, sample: TestSample) -> set:
        # Implement your strategy here.
        # 
        # 
        # Your goal is to return the indices of the positive samples
        # while minimizing the number of calls to sample.query
        #
        # Not correctly identifying the set of positive samples results in disqualification!
        #
        # The input will be a TestSample object, which allows you to query
        # a subset of 0 ... n-1
        #
        # sample.query([1, 3, 4]) will return True if any of 1, 3, or 4 are positive
        # k = math.ceil(math.sqrt(self.n))
        k = 2

        return self.isolate_positives_helper(sample, 0, self.n-1, k, 2)

    def isolate_positives_helper(self, sample: TestSample, start, end, k, l) -> set:
        current_n = end - start + 1
        # Base Case
        if current_n <= l:
            return {i for i in range(start, end+1) if sample.query(set([i]))}
        else:
            # divide into k chunks
            cur_samples = [i for i in range(start, end+1)]
            has_positive = sample.query(set(cur_samples))
            
            positives = set()
            if has_positive:
                chunk_size = math.ceil(current_n / k)
                for i in range(k):
                    cur_start = i*chunk_size + start
                    cur_end = min(end, cur_start + chunk_size-1)
                    positives.update(self.isolate_positives_helper(sample, cur_start, cur_end, k, l))
            return positives
