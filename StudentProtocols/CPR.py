# DO NOT EDIT THIS FILE
# Copy this file and implement your own Protocol.isolate_positives method
#
# Create a new branch w/ your team name as the branch name
# git checkout -b your_team_name
#
# Add the file to the git repo
# git add your_file
#
# Commit it
# git commit your_file -m "A nice message"
#
# Push to your branch
# git push origin your_team_name
#
# Create a Pull Request whenever you're ready to test your method against others

from .utils import TestSample

from collections import deque
class Protocol:
    def __init__(self, population_size: int, prevalence: float):
        self.n = population_size
        self.p = prevalence
        self.THRESHOLD = .5
    
    def prob(self, n):
        return (1 - (1 - self.p) ** n)

    def split(self, lst, split_factor):
        res = []
        length = len(lst) // split_factor
        for i in range(0, len(lst), length):
            res.append(lst[i: i + length])

        return res 

    def isolate_positives(self, sample: TestSample) -> set:
        # Implement your strategy here.
        # 
        # Your goal is to return the indices of the positive samples
        # while minimizing the number of calls to sample.query
        #
        # Not correctly identifying the set of positive samples results in disqualification!
        #
        # The input will be a TestSample object, which allows you to query
        # a subset of 0 ... n-1
        #
        # sample.query([1, 3, 4]) will return True if any of 1, 3, or 4 are positive
        q = deque()
        prob = self.prob(self.n)
        if prob >= self.THRESHOLD:
            # Do big sample at start
            q.append([i for i in range(self.n)])
        else:
            # Do small sample at start
            for split in self.split(range(self.n), 2):
                q.append(split)
        
        positive_results = set()
        
        while q:
            for _ in range(len(q)):
                sub_sample = q.popleft()
                test_result = sample.query(sub_sample)

                if test_result:
                    # Base case where we only have one positive person.           
                    if len(sub_sample) == 1:
                        positive_results.add(sub_sample[0])

                    # Special case where we have only two people, where at least one is positive.
                    elif len(sub_sample) == 2:
                        # Check if first person is positive. If not, then we add only the second person.
                        first_person = sample.query([sub_sample[0]])
                        if not first_person:
                            positive_results.add(sub_sample[1])
                            continue            

                        # if here, we know the first person is positive and still need to check second
                        positive_results.add(sub_sample[0])
                        second_person = sample.query([sub_sample[1]])
                        if second_person:
                            positive_results.add(sub_sample[1])
                    else:
                        split_factor = 2
                        if self.prob(len(sub_sample)) >= self.THRESHOLD:
                            split_factor = 4
                        for split in self.split(sub_sample, split_factor):
                            q.append(split)
            
        return positive_results