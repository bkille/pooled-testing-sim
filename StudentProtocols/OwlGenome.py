# DO NOT EDIT THIS FILE
# Copy this file and implement your own Protocol.isolate_positives method
#
# Create a new branch w/ your team name as the branch name
# git checkout -b your_team_name
#
# Add the file to the git repo
# git add your_file
#
# Commit it
# git commit your_file -m "A nice message"
#
# Push to your branch
# git push origin your_team_name
#
# Create a Pull Request whenever you're ready to test your method against others

from .utils import TestSample

class Protocol:
    def __init__(self, population_size: int, prevalence: float):
        self.n = population_size
        self.p = prevalence
    
    def isolate_positives(self, sample: TestSample) -> set:
        '''Function that returns the indices of the positive samples
        Input: a TestSample object
        Output: Set of sample indices that are true
        '''
        sample_indices = list(range(self.n))   # create list of indices â±¯ (n) samples
        return self.binary_splitting(sample, sample_indices)

    def binary_splitting(self, sample: TestSample, sample_indices) -> set:
        '''Binary Splitting strategy'''
        true_samples = set()    # Initialize & store indices of pos. samples

        def _binary_splitting_recursive(sample_indices):
            '''Binary splitting method'''
            # Splitting indices list into 2 halves 
            mid = len(sample_indices) // 2
            left_idxs = sample_indices[:mid]    # Left-half indices
            right_idxs = sample_indices[mid:]   # Right-half indices
            ## If only 2 samples, check individually
            if len(sample_indices) == 2:
                if not sample.query(left_idxs): ## if not left, must be right
                    true_samples.add(sample_indices[1])
                else: ## If left, must also check right
                    true_samples.add(sample_indices[0]) 
                    if sample.query(right_idxs):
                        true_samples.add(sample_indices[1])
                return
            if sample.query(left_idxs):
                # If left half contains pos. samples, recurse into left half
                _binary_splitting_recursive(left_idxs)
            if sample.query(right_idxs):
                # If right half contains pos. samples, recurse into right half
                _binary_splitting_recursive(right_idxs)

        if self.p > 0.2: ## if probability is very high, use baseline method
            return {i for i in range(self.n) if sample.query(set([i]))}
        elif self.p < (1/len(sample_indices)): ## If probability is smaller than total batch size
            if sample.query(sample_indices): ## Check batch
                _binary_splitting_recursive(sample_indices)     # Begin recurcive split
        else:
            _binary_splitting_recursive(sample_indices)     # Begin recurcive split
        return true_samples     # Return set of pos. sample indices
